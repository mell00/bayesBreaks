---
title: "Getting started with bayesBreaks"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with bayesBreaks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  fig.width = 8,
  fig.height = 4.5,
  dpi = 144,
  out.width = "85%"
)
```

```{r setup}
if (requireNamespace("bayesBreaks", quietly = TRUE)) {
  library(bayesBreaks)
} else {
  if (!requireNamespace("pkgload", quietly = TRUE)) {
    stop("Install bayesBreaks or pkgload to knit this vignette")
  }
  pkgload::load_all(export_all = FALSE)
}

if (!requireNamespace("ggplot2", quietly = TRUE)) {
  stop("Install ggplot2 to knit this vignette.")
}
library(ggplot2)

plot_theme <- function() {
  theme_minimal(base_size = 12) +
    theme(
      panel.grid.minor = element_blank(),
      plot.title.position = "plot",
      plot.title = element_text(face = "bold"),
      legend.position = "top",
      legend.title = element_blank()
    )
}

set.seed(600)  # keep all simulated draws reproducible
```

## Overview

The `bayesBreaks` package combines an autoregressive time-series fitter, a
frequentist Baiâ€“Perron style grid search, and a Bayesian breakpoint sampler.
This vignette walks through each component using the built-in simulated
datasets and shows how you would apply the same calls to your own series.

This vignette walks through a short workflow:

1. simulate a toy series with known breakpoints,
2. run the Bai-Perron search as a baseline, and
3. sample breakpoint configurations with `baar()`.

## Exploring the shipped test data

All of the development datasets are bundled in `data/` and can be loaded with
`data(<name>)`. They are two-column data frames with `time` indices and
a single response column. Below we visualize `data_2`, which contains two
clearly separated mean shifts.

```{r}
data(data_2)
plot(
  data_2$time, data_2$data_2,
  type = "l", col = "#1E88E5",
  xlab = "Time", ylab = "Value",
  main = "Example series: data_2"
)
```

If you want to generate new draws on the fly, you can also call the helper
functions (for example `test_data_2()`) directly after setting your own seed.

## Simulating a series with three shifts

The `test_data_*()` helpers in the package generate synthetic time series used
while developing the sampler. We will use `test_data_2()`, which contains three
segments with different means.

```{r simulate}
series <- test_data_2()
head(series)
```

A simple plot shows the level shifts built into the generator.

```{r simulate-plot, fig.height=4, fig.width=7, tidy=FALSE, echo=FALSE}
ggplot(series, aes(time, data_2)) +
  geom_line(color = "#2F3E63", linewidth = 0.6) +
  geom_vline(
    xintercept = c(30, 60),
    color = "#C73339",
    linetype = "dashed",
    linewidth = 0.8
  ) +
  labs(
    title = "Synthetic series with three mean shifts",
    x = "time",
    y = "value"
  ) +
  plot_theme()
```

## Frequentist baseline with Bai-Perron

The `bai_perron_ar()` helper evaluates all admissible segmentations up to a
user-specified maximum number of breakpoints and returns the configuration with
the smallest Bayesian information criterion (BIC). Using a low autoregressive
order keeps the example quick to run.

```{r bai-perron}
bp <- bai_perron_ar(data = series$data_2, order = 0, interval = 0.1,
                    max_breaks = 3, progress = FALSE)
bp$breakpoints
bp$BIC
```

The BIC curve highlights that the two-break model is preferred for this series.

```{r bai-perron-plot, fig.height=3.8, fig.width=6.5}
bic_df <- data.frame(
  breaks = seq_along(bp$BIC) - 1,
  bic = bp$BIC
)

ggplot(bic_df, aes(breaks, bic)) +
  geom_line(color = "#2F3E63", linewidth = 0.7) +
  geom_point(color = "#2F3E63", size = 2.5) +
  geom_vline(xintercept = bic_df$breaks[which.min(bic_df$bic)],
             linetype = "dashed", color = "#1A85FF", linewidth = 0.9) +
  labs(
    title = "Bai-Perron fit preferred a two-break model",
    x = "number of breakpoints",
    y = "BIC"
  ) +
  plot_theme()
```

## Sampling breakpoints with BAAR

`baar()` explores breakpoint configurations with a Metropolis-Hastings sampler
that proposes adding, removing, moving, and jiggling breakpoints. For vignette
speed we keep the iteration count small; for real analyses you will want longer
chains and multiple seeds.

```{r baar}
baar_fit <- baar(
  time = series$time,
  data = series$data_2,
  iterations = 200,
  burn_in = 50,
  make_murder_p = 0.5,
  percent = 0.05,
  lambda = 1,
  jump_p = 0.25,
  ar = 0,
  progress = FALSE,
  fit_storage = FALSE
)
str(baar_fit)
```

The sampler returns the sampled breakpoint sets (`Breakpoints`) and a vector
tracking the number of breakpoints per draw (`NumBkpts`). We can examine the
posterior distribution over breakpoint counts and the empirical frequency of
individual break locations.

```{r baar-summary, fig.height=4, fig.width=7}
count_df <- as.data.frame(table(baar_fit$NumBkpts))
names(count_df) <- c("breaks", "frequency")

ggplot(count_df, aes(as.numeric(as.character(breaks)), frequency)) +
  geom_col(fill = "#1A85FF", width = 0.7) +
  labs(
    title = "Posterior mass on breakpoint counts",
    x = "number of breakpoints",
    y = "posterior frequency"
  ) +
  scale_x_continuous(breaks = unique(as.numeric(as.character(count_df$breaks)))) +
  plot_theme()
```

```{r baar-breaks, fig.height=4, fig.width=7, tidy=FALSE}
# gather breakpoint positions from each draw
all_breaks <- unlist(baar_fit$Breakpoints)
break_df <- data.frame(breaks = all_breaks)

true_breaks <- data.frame(breaks = c(30, 60))

bp_lines <- data.frame(
  breaks = c(bp$breakpoints, true_breaks$breaks),
  source = c(
    rep("Bai-Perron", length(bp$breakpoints)),
    rep("true", nrow(true_breaks))
  )
)

ggplot(break_df, aes(breaks)) +
  geom_histogram(
    breaks = seq(0.5, max(series$time) + 0.5, by = 1),
    fill = "#7DB0FF", color = "white"
  ) +
  geom_vline(
    data = bp_lines,
    aes(xintercept = breaks, linetype = source, color = source),
    linewidth = 0.9,
    show.legend = TRUE
  ) +
  labs(
    title = "Empirical breakpoint locations",
    x = "time index",
    y = "posterior count"
  ) +
  plot_theme()
```

Even with a short run, the BAAR sampler concentrates mass near the two true
breakpoints and agrees with the Bai-Perron search on the preferred breakpoint
count. Increasing the number of iterations and the autoregressive order allows
for richer fits when analysing real data.

## Stress-testing on noisier series

The package includes more extreme toy datasets that expose challenges such as
large jumps and near-unit-root behaviour. They provide quick checks that the
baseline and sampler still recover the main structure.

### Wide variance swings

`test_data_4()` introduces three mean shifts plus substantial noise, making the
true changes less visually obvious than in the earlier example.

```{r simulate-extreme-variance}
noisy <- test_data_4()
ggplot(noisy, aes(time, data_4)) +
  geom_line(color = "#2F3E63", linewidth = 0.6) +
  geom_vline(xintercept = c(30, 60),
             color = "#C73339", linetype = "dashed", linewidth = 0.8) +
  labs(
    title = "Noisy series with three broad shifts",
    x = "time",
    y = "value"
  ) +
  plot_theme()
```

Even under high variance, the Bai-Perron BIC search still points to two
breakpoints when the autoregressive order stays low.

```{r bai-perron-extreme-variance}
bp_noisy <- bai_perron_ar(noisy$data_4, order = 0, interval = 0.1,
                         max_breaks = 4, progress = FALSE)
bic_noisy <- data.frame(breaks = seq_along(bp_noisy$BIC) - 1,
                        bic = bp_noisy$BIC)

ggplot(bic_noisy, aes(breaks, bic)) +
  geom_line(color = "#2F3E63", linewidth = 0.7) +
  geom_point(color = "#2F3E63", size = 2.5) +
  geom_vline(xintercept = bic_noisy$breaks[which.min(bic_noisy$bic)],
             linetype = "dashed", color = "#1A85FF", linewidth = 0.9) +
  labs(
    title = "Bai-Perron search on noisy series",
    x = "number of breakpoints",
    y = "BIC"
  ) +
  plot_theme()
```

Running a short BAAR chain still concentrates posterior mass near the break
locations despite the noise.

```{r baar-extreme-variance}
baar_noisy <- baar(
  time = noisy$time,
  data = noisy$data_4,
  iterations = 300,
  burn_in = 75,
  make_murder_p = 0.5,
  percent = 0.05,
  lambda = 1,
  jump_p = 0.25,
  ar = 0,
  progress = FALSE,
  fit_storage = FALSE
)

noisy_break_df <- data.frame(breaks = unlist(baar_noisy$Breakpoints))

noisy_lines <- data.frame(
  breaks = c(bp_noisy$breakpoints, 30, 60),
  source = c(rep("Bai-Perron", length(bp_noisy$breakpoints)), rep("true", 2))
)

ggplot(noisy_break_df, aes(breaks)) +
  geom_histogram(
    breaks = seq(0.5, max(noisy$time) + 0.5, by = 1),
    fill = "#7DB0FF", color = "white"
  ) +
  geom_vline(
    data = noisy_lines,
    aes(xintercept = breaks, linetype = source, color = source),
    linewidth = 0.9
  ) +
  scale_color_manual(values = c("Bai-Perron" = "#1A85FF", "true" = "#C73339")) +
  scale_linetype_manual(values = c("Bai-Perron" = "dashed", "true" = "dotdash")) +
  labs(
    title = "Posterior breakpoints on noisy series",
    x = "time index",
    y = "posterior count"
  ) +
  plot_theme()
```


### Abrupt shifts in persistence

`test_data_11()` flips the order of an autoregressive process, simulating a
highly persistent regime that suddenly becomes much less persistent. These
changes are harder for simple variance-based heuristics to detect.

```{r simulate-persistence}
persistent <- test_data_11()
ggplot(persistent, aes(time, data_11)) +
  geom_line(color = "#2F3E63", linewidth = 0.6) +
  geom_vline(xintercept = 45, color = "#C73339", linetype = "dashed",
             linewidth = 0.8) +
  labs(
    title = "Near unit-root segment followed by mild AR",
    x = "time",
    y = "value"
  ) +
  plot_theme()
```

Because the main change is in the autocorrelation structure, providing an
autoregressive order helps both the Bai-Perron search and BAAR sampler.

```{r bai-perron-persistence}
bp_persist <- bai_perron_ar(persistent$data_11, order = 1, interval = 0.1,
                            max_breaks = 2, progress = FALSE)
bp_persist$breakpoints
```

```{r baar-persistence}
baar_persist <- baar(
  time = persistent$time,
  data = persistent$data_11,
  iterations = 300,
  burn_in = 75,
  make_murder_p = 0.5,
  percent = 0.05,
  lambda = 1,
  jump_p = 0.25,
  ar = 1,
  progress = FALSE,
  fit_storage = FALSE
)
persist_counts <- as.data.frame(table(baar_persist$NumBkpts))
names(persist_counts) <- c("breaks", "frequency")

ggplot(persist_counts, aes(as.numeric(as.character(breaks)), frequency)) +
  geom_col(fill = "#1A85FF", width = 0.7) +
  labs(
    title = "Breakpoint counts with AR(1) structure",
    x = "number of breakpoints",
    y = "posterior frequency"
  ) +
  scale_x_continuous(breaks = unique(as.numeric(as.character(persist_counts$breaks)))) +
  plot_theme()
```

Even in these more extreme settings, quick diagnostic runs show that
`bai_perron_ar()` and `baar()` adapt to noisy changes in mean and in
autocorrelation when provided with appropriate autoregressive structure.
